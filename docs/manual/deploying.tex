\chapter{Deploying}

Mongrel2 is designed to be easy to deploy and \emph{automate} the deployment.
This is why it uses \href{http://www.sqlite.org/}{SQLite} to store the configuration,
but \shell{m2sh} as an interface to creating the configuration.  Doing this lets
you access the configuration using any language that works for you, augment it,
alter it, migrate it, and automate it.

In this chapter I'm going to show you how to make a basic configuration using
m2sh and all the commands that are available.  You'll learn how the configuration
system is structured so that you know what goes where, but in the end it's just
a simple storage mechanism.

\begin{aside}{Apparently SQL Inspires FUD}
When I first started talking about Mongrel2 I said I'd store the configuration
in SQLite and do a Model-View-Controller kind of design.  Immediately people who
can't read flipped out and though this meant they'd be back in "windows registry hell"
but with SQL as their only way to access it.  They thought that they'd be stuck writing
configurations with SQL.  That SQL couldn't possibly configure a web server.

They were wrong on many levels.  Nobody was \emph{ever} going to make \emph{anyone} use
SQL.  That was repeated over and over, but again, people don't read and love spreading
FUD.  The SQLite config database is nothing like the Windows Registry.  No other web
server really uses a true hierarchy, they just cram a relational model into a weirdo
configuration format.  The real goal was to make a web server that was easy to manage from
\emph{any} language, and then give people a nice tool to get their job done without
having to ever touch SQL.  \emph{EVER!}

In the end, what we got despite all this fear mongering is a bad ass configuration
tool and a design that is simple, elegant, and works fantastic.  If you read that
Mongrel2 uses SQLite and though this was weird, well welcome to the future.  Sometimes
it's weird out here (even though, Postfix has been doing this for a decade or more).
\end{aside}


\section{Model-View-Controller}

When you hear Model-View-Controller you think about web applications.  This is a design pattern
where you place different concerns into different parts of your system and try not to mix them
too much.  For an interactive application, if you keep the part that stores data (Model) separated
from the logic (Controller) and use another piece to display and interact with the user (View) then
it's easier to change the system and adapt it over time to new features.

The power of MVC is simply that these things really are separate orthogonal pieces that get
ugly if they're mixed together.  There's not math or theory that says why, just lots of 
experience has told us it's usually a bad idea.  When you start mixing them you find out that
it's hard to change for new requirements later because you've sprinkled logic all over your
web pages.  Or you can't update your database because there's all these stored procedures that
assume the tables are a certain way.

Mongrel2 needed a way to allow you to use various languages and tools to automate its configuration.
Letting you automate your deployments is the entire point of the server.  The idea was that if we
gave you the Controller and the Model, then you can craft any \emph{View} you wanted, and there's
no better Model than a SQL database like SQLite.  It's embeddable, easily accessed from C or any
language, portable, small, fast enough, and full of all the features you need and then some.

What you are doing when you use m2sh to configure a configuration for Mongrel2 is working with
a View we've given you to create a Model for the Mongrel2 server to work with.  That's it, and
you can create your own View if you want.  It could be automated deployment scripts, a web
interface, monitoring scripts, anything you need.

The point is, if you just want to get Mongrel2 up and running, then use m2sh.  If you want to
do more advanced stuff, then get into the configuration database schema and see what you can
do.  The structure of the database very closely matches Mongrel2's internal structure, so 
understanding that means you understand how Mongrel2 works.  This is a vast improvement over
other web servers like Apache where you've got no idea why one stanza has to go in a particular
place, or why information has to be duplicated.

With Mongrel2 it's all right there.


\section{Trying m2sh}

To give this configuration system a try you just need to run the test configuration used
in the unit tests.  Let's try doing a few of the most basic commands with this configuration:

\begin{code}{Sample m2sh Commands}
\begin{verbatim}
> m2sh dump -db tests/config.sqlite
> m2sh servers -db tests/config.sqlite
> m2sh hosts -db tests/config.sqlite -host localhost
> m2sh running -db tests/config.sqlite -host localhost
> m2sh start -db tests/config.sqlite -host localhost
\end{verbatim}
\end{code}

At this point you should have seen some raw dumps of the database, lists of servers and hosts,
seen that mongrel2 is not running, and then started it.  You can find out about all the commands
and get help for them with \shell{m2sh help} or \shell{ms2h help -for command}.

You can now try doing some simple starting, stopping and reloading using sudo (make sure you CTRL-c
to exit from the previous start command):

\begin{code}{Starting, Stopping, Reloading}
\begin{verbatim}
> m2sh start -db tests/config.sqlite -host localhost -sudo
> tail logs/error.log
> m2sh reload -db tests/config.sqlite -host localhost
> tail logs/error.log
> curl http://localhost:8080/
> tail logs/error.log
> m2sh running -db tests/config.sqlite -host localhost
> m2sh stop -db tests/config.sqlite -host localhost
\end{verbatim}
\end{code}

Awesome right?  Using just this one little Python management script you 
are able to completely manage a mongrel2 instance without having to hack
on a config file at all.  But you probably need to know how this is all 
working anyway.


\subsection{What The Hell Just Happened?}

You now have done nearly everything you can to a configuration, but you might not know exactly
what's going on.  Here's an explanation of what's going on behind the scenes:

\begin{enumerate}
\item When you did \shell{m2sh start} with the \shell{-sudo} option it actually runs
    \shell{sudo mongrel2 tests/config.sqlite localhost} to start the server.
\item Mongrel2 is now running in the background as a daemon process, just like a regular server
    however what it did was chroot to the current directory and then drop privileges so that 
    they match the owner of that directory (you).  Use \shell{ps aux} to take a look.
\item With Mongrel2 running you can look in the logs/error.log file to see what it said.  It should
    be a bunch of debug logging but check out the messages, nice and detailed.
\item Next you did a soft reload with \shell{m2sh reload} and you should notice that your mongrel2
    process was able to load the new config \emph{without restarting}.
\item However, there's a slight bug that doesn't do the reload until the next request is served, that's
    what the \shell{curl http://localhost:8080/} was for.
\item Now that you can see this reload work in the \file{logs/error.log} you used \shell{m2sh running} to
    see if it's running.  This command is just reading the config database to find out where the PID file
    is (\file{run/mongrel2.pid}) and then checking if that process is running.
\item Finally, you tell mongrel2 to stop, and since it dropped privileges to be owned by you, you can do
    that without having to use sudo.
\end{enumerate}

All of this is happening by reading the \file{tests/config.sqlite} file and not reading any configuration
files.  You can now try building your own configuration that matches this one or some others.


\section{A Simple Configuration File}

To configure a new config database you'll write a Python file that looks a lot like
a configuration file.  The advantage of using Python is that you can put actual
real logic in your configuration file in order to make your configuration smarter.
A great application of this is when your configuration has to change depending on the
server it is deployed on, but you want to check the configuration file into a revision
control system.  With Python you just write your configuration like it's code and
you're set.

The first thing you need to do is initialize a fresh configuration database to get
started by using \shell{m2sh init} and then you load your configuration using
\shell{m2sh load}.  As an example, we'll use the example configuration
from \file{examples/python/tests/sample_conf.py} to make a simple one:

\begin{code}{Simple Little Config Example}
\begin{verbatim}
from mongrel2.config import *

main = Server(
    uuid="f400bf85-4538-4f7a-8908-67e313d515c2",
    access_log="/logs/access.log",
    error_log="/logs/error.log",
    chroot="./",
    default_host="localhost",
    pid_file="/run/mongrel2.pid",
    port=6767,
    hosts = [
        Host(name="localhost", routes={
            '/tests/': Dir(base='tests/', index_file='index.html',
                             default_ctype='text/plain')
        })
    ]
)

commit([main])
\end{verbatim}
\end{code}

If you aren't familiar with Python then this code might look freaky, but it's really
simple.  Well get into how its structured in a second, but to load this file
we would just do this:

\begin{code}{Loading The Simple Config}
\begin{verbatim}
> m2sh init -db simple.sqlite
> m2sh load -db simple.sqlite -config examples/python/tests/sample_conf.py
> m2sh servers -db simple.sqlite
> m2sh hosts -db simple.sqlite -host localhost
> m2sh start -db simple.sqlite -host localhost
\end{verbatim}
\end{code}

With this sequence of commands you:

\begin{enumerate}
\item Create a raw fresh config database name \file{simple.sqlite}
\item Load the \file{sample_conf.py} into it.
\item List the servers it has configured.
\item List the hosts that server has, with what routes it has.
\item Start this server to try it out.
\end{enumerate}

By now you should be getting the hang of the pattern here, which is to use
m2sh and little Python configuration "script" to generate .sqlite files
that Mongrel2 understands.

\section{How A Config Is Structured}

The base structure of a Mongrel2 configuration is:

\begin{description}
\item[Server] This is the root of a config, and you can have multiples of these in one database,
    even though each start command only runs one at a time.
\item[Host] Servers then have Hosts inside them which say what DNS hostname Mongrel2 should answer for, and
    you can have multiples of these in each Server.
\item[Route] Hosts have Routes in them which tells Mongrel2 what to do with URL paths and patterns
    that match them.  Routes then have \ident{Dir}, \ident{Handler}, and \ident{Proxy} items in them.
\item[Dir] A Dir serves files out of a directory, full with 304 and ETag support, default content types, 
    and most of the things you need to serve them.
\item[Proxy] A Proxy takes requests matching the Route they're attached to and sends them to another
    HTTP server somewhere else.  Mongrel2 will then act as a full proxy and also try to keep connections
    open in keep-alive mode if the browser supports it.
\item[Handler] A Handler is the best part of Mongrel2.  It takes HTTP requests, and turns them into 
    nicely packed and processed ZeroMQ messages for your asynchronous handlers.
\end{description}

Each of these nested "objects" then has a set of attributes you can use to configure them, and
most of them have reasonable defaults.


\subsection{Server}

The server is all about telling Mongrel2 where to listen on its port, where to chroot,
and general server specific deployment gear.

\begin{description}
\item[uuid] A UUID is used to make sure that each deployed server is unique in your infrastructure.
    You could easily use any string that's letters, numbers, or - characters.
\item[chroot] This is the directory that Mongrel2 should chroot to and drop privileges.
\item[access_log] The access log file \emph{relative to the chroot}.  Usually starts with a '/'.  Make sure
    you don't configure your server so that this and other files are accessible, or make this owned by root.
\item[error_log] The error log file just like access_log.
\item[pid_file] Like the access log, where within the chroot directory is the pid file stored.
\item[default_host] The server has a bunch of hosts listed, but it needs to know what the default host is.  This is also
    used as a convenient way to refer to this Server.
\item[port] The port the server should listen on for new connections.
\end{description}

\subsection{Host}


\subsection{Route}



\subsection{Dir}



\subsection{Proxy}



\subsection{Handler}



\section{A More Complex Example}


\section{Routing And Host Patterns}



\section{Deployment Logs And Commits}






