\chapter{Deploying}

Mongrel2 is designed to be easy to deploy and \emph{automate} the deployment.
This is why it uses \href{http://www.sqlite.org/}{SQLite} to store the configuration,
but \shell{m2sh} as an interface to creating the configuration.  Doing this lets
you access the configuration using any language that works for you, augment it,
alter it, migrate it, and automate it.

In this chapter I'm going to show you how to make a basic configuration using
m2sh and all the commands that are available.  You'll learn how the configuration
system is structured so that you know what goes where, but in the end it's just
a simple storage mechanism.

\begin{aside}{Apparently SQL Inspires FUD}
When I first started talking about Mongrel2 I said I'd store the configuration
in SQLite and do a Model-View-Controller kind of design.  Immediately people who
can't read flipped out and though this meant they'd be back in "windows registry hell"
but with SQL as their only way to access it.  They thought that they'd be stuck writing
configurations with SQL.  That SQL couldn't possibly configure a web server.

They were wrong on many levels.  Nobody was \emph{ever} going to make \emph{anyone} use
SQL.  That was repeated over and over, but again, people don't read and love spreading
FUD.  The SQLite config database is nothing like the Windows Registry.  No other web
server really uses a true hierarchy, they just cram a relational model into a weirdo
configuration format.  The real goal was to make a web server that was easy to manage from
\emph{any} language, and then give people a nice tool to get their job done without
having to ever touch SQL.  \emph{EVER!}

In the end, what we got despite all this fear mongering is a bad ass configuration
tool and a design that is simple, elegant, and works fantastic.  If you read that
Mongrel2 uses SQLite and though this was weird, well welcome to the future.  Sometimes
it's weird out here (even though, Postfix has been doing this for a decade or more).
\end{aside}


\section{Model-View-Controller}

When you hear Model-View-Controller you think about web applications.  This is a design pattern
where you place different concerns into different parts of your system and try not to mix them
too much.  For an interactive application, if you keep the part that stores data (Model) separated
from the logic (Controller) and use another piece to display and interact with the user (View) then
it's easier to change the system and adapt it over time to new features.

The power of MVC is simply that these things really are separate orthogonal pieces that get
ugly if they're mixed together.  There's not math or theory that says why, just lots of 
experience has told us it's usually a bad idea.  When you start mixing them you find out that
it's hard to change for new requirements later because you've sprinkled logic all over your
web pages.  Or you can't update your database because there's all these stored procedures that
assume the tables are a certain way.

Mongrel2 needed a way to allow you to use various languages and tools to automate its configuration.
Letting you automate your deployments is the entire point of the server.  The idea was that if we
gave you the Controller and the Model, then you can craft any \emph{View} you wanted, and there's
no better Model than a SQL database like SQLite.  It's embeddable, easily accessed from C or any
language, portable, small, fast enough, and full of all the features you need and then some.

What you are doing when you use m2sh to configure a configuration for Mongrel2 is working with
a View we've given you to create a Model for the Mongrel2 server to work with.  That's it, and
you can create your own View if you want.  It could be automated deployment scripts, a web
interface, monitoring scripts, anything you need.

The point is, if you just want to get Mongrel2 up and running, then use m2sh.  If you want to
do more advanced stuff, then get into the configuration database schema and see what you can
do.  The structure of the database very closely matches Mongrel2's internal structure, so 
understanding that means you understand how Mongrel2 works.  This is a vast improvement over
other web servers like Apache where you've got no idea why one stanza has to go in a particular
place, or why information has to be duplicated.

With Mongrel2 it's all right there.


\section{Trying m2sh}

To give this configuration system a try you just need to run the test configuration used
in the unit tests.  Let's try doing a few of the most basic commands with this configuration:

\begin{code}{Sample m2sh Commands}
\begin{verbatim}
> m2sh dump -db tests/config.sqlite
> m2sh servers -db tests/config.sqlite
> m2sh hosts -db tests/config.sqlite -host localhost
> m2sh running -db tests/config.sqlite -host localhost
> m2sh start -db tests/config.sqlite -host localhost
\end{verbatim}
\end{code}

At this point you should have seen some raw dumps of the database, lists of servers and hosts,
seen that mongrel2 is not running, and then started it.  You can find out about all the commands
and get help for them with \shell{m2sh help} or \shell{ms2h help -for command}.

You can now try doing some simple starting, stopping and reloading using sudo (make sure you CTRL-c
to exit from the previous start command):

\begin{code}{Starting, Stopping, Reloading}
\begin{verbatim}
> m2sh start -db tests/config.sqlite -host localhost -sudo
> tail logs/error.log
> m2sh reload -db tests/config.sqlite -host localhost
> tail logs/error.log
> curl http://localhost:8080/
> tail logs/error.log
> m2sh running -db tests/config.sqlite -host localhost
> m2sh stop -db tests/config.sqlite -host localhost
\end{verbatim}
\end{code}

Awesome right?  Using just this one little Python management script you 
are able to completely manage a mongrel2 instance without having to hack
on a config file at all.  But you probably need to know how this is all 
working anyway.


\subsection{What The Hell Just Happened?}

You now have done nearly everything you can to a configuration, but you might not know exactly
what's going on.  Here's an explanation of what's going on behind the scenes:

\begin{enumerate}
\item When you did \shell{m2sh start} with the \shell{-sudo} option it actually runs
    \shell{sudo mongrel2 tests/config.sqlite localhost} to start the server.
\item Mongrel2 is now running in the background as a daemon process, just like a regular server
    however what it did was chroot to the current directory and then drop privileges so that 
    they match the owner of that directory (you).  Use \shell{ps aux} to take a look.
\item With Mongrel2 running you can look in the logs/error.log file to see what it said.  It should
    be a bunch of debug logging but check out the messages, nice and detailed.
\item Next you did a soft reload with \shell{m2sh reload} and you should notice that your mongrel2
    process was able to load the new config \emph{without restarting}.
\item However, there's a slight bug that doesn't do the reload until the next request is served, that's
    what the \shell{curl http://localhost:8080/} was for.
\item Now that you can see this reload work in the \file{logs/error.log} you used \shell{m2sh running} to
    see if it's running.  This command is just reading the config database to find out where the PID file
    is (\file{run/mongrel2.pid}) and then checking if that process is running.
\item Finally, you tell mongrel2 to stop, and since it dropped privileges to be owned by you, you can do
    that without having to use sudo.
\end{enumerate}

All of this is happening by reading the \file{tests/config.sqlite} file and not reading any configuration
files.  You can now try building your own configuration that matches this one or some others.


\section{A Simple Configuration File}


\section{A More Complex Example}


\section{How It's Structured}


\section{More Advanced m2sh}



\section{Writing Your Own m2sh}


