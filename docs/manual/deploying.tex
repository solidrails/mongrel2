\chapter{Deploying}

I am now going to try to get you to setup a small tiny little version of a good
deployment that matches the \url{http://mongrel2.org} site's configuration with
all the examples running.  This configuration will give you all the tools you 
need to make automated and managed deployments, but it is using small scale tools.
The idea is that you learn what is involved in a nice easy to manage setup using simple
things first, then you can extrapolate that out into your own setup or something
better.


\section{Mongrel2 Deployment Requirements}

It may seem obvious but I'll go over the things you need in order to continue
on in this section:

\begin{description}
\item [Mongrel2] I know, hard to believe, but you actually need to have Mongrel2 installed.
\item [m2sh] Again, not sure why but some folks think they don't need this.  Unless you've
    got your own written you need \shell{m2sh}.
\item [Python] Obviously if you have \shell{m2sh} then you have Python, but some systems
    (like Debian) don't install all of Python.  Make sure your Python setup is good.
\item [root] You'll need root access on your box.  Either through sudo or some other means.
\item [Basic Python Coding] Right now you should be able to do some basic Python. 
\end{description}

That will get you going at first, and as we go we'll do various other setups to 
get our application working.

\begin{aside}{Learning Python}
Why should you learn programming?  The trend is that if you are a system administrator
who can't code then you are on your way out.  Eventually you'll be in charge of automating
systems not manually managing them, and if you don't believe me then what do you think all
those managed service companies are doing?  Alright, so you need to learn to code, but
most of the books suck for really learning if you know nothing.

This is why I started my own book \emph{Learn Python The Hard Way} for people
who know nothing about programming but need or want to learn.  It teaches
Python but it mostly teaches all the things programmers actually learn before
they learn programming.  When you're done with my book you'll have you
"programming brown belt".  That means you can then move onto one of many other
free online books and really learn programming, and have a higher chance of
actually learning it.

If you can't code Python then you can probably muddle through this and you may
learn something, but learning Python will be important later.  If you don't
know Python and want a good introduction then I will pimp my book
\href{http://learnpythonthehardway.org}{Learn Python The Hard Way} which is a
totally free book that teaches Python as if you know nothing.  Give it a try,
or any of the other free books I mention

But \emph{don't} read "Dive Into Python" as it is a horrible introduction.
\end{aside}

\subsection{Introducing procer}

When I started working on this little manual I wanted to get you into setting up
a well managed and automated deployment system.  The \shell{m2sh} program does 
much of the automation you need, but Mongrel2 also has to talk to quite a few 
separate little pieces that run as separate processes.  Trying to juggle all these
processes without a tool to help is a nightmare.  You end up writing init scripts
and merging them into your boot process and all sorts of crazy antics just so you
can run a stupid hello world demo.

What I needed was a "user space process manager".  These are programs that run other
programs, but more importantly try to keep those other programs running without much
human intervention.  When you need to deploy a ton of processes that all have to
be running, these USPMs are fantastic.  They usually read some startup profile describing
what needs to start and what they depend on, and then it kicks everything into gear
and watches them.  If any of the processes crash they try to restart them.  Very simple.

There's just one catch, all of them suck.  There's \href{http://cr.yp.to/daemontools.html}{daemontools}
which barely builds (if at all) and then assumes that daemons don't fork.  Stupid.  There's 
\href{http://www.fefe.de/minit/}{minit} which bafflingly required dietlibc to even compile
and assumed it was going to be the one true init (not user space at all).  There's 
\href{http://www.nico.schottelius.org/software/cinit/}{cinit} which got through a compile
then barfed on its documentation, and the end result is some huge number of weird 
shell scripts to make it work, and again it wants to be the one true init.  Finally 
\href{http://smarden.org/runit/}{runit} is some of the worst C code I've seen in years and
has the same weird design as daemontools.

After trying every single one I just gave up.  Either they didn't build, were too complex,
expected to be the one true init, poorly documented, not maintained, and definitely not
going to work for this manual.  My only choice was to shave a yak and write my own.

The end result is \shell{procer} which lives in \file{examples/procer} and does
most of what you need in a USPM.  It works a lot like daemontools or minit but
is much simpler with these differences:

\begin{enumerate}
\item It is much simpler, with only a single command to start all your stuff and
    keep it running.
\item It will build anywhere Mongrel2 will build because it reuses the \file{libm2.a}
    library from the Mongrel2 project.
\item It doesn't want to be the one true init, or expect to be running constantly even.
    You can start it and stop it and it will only run what's not already running.
\item It assumes that programs will always daemonize and create a PID file.  This turns
    out to be way easier to manage than what daemontools does, so I'm sort of baffled why
    daemontools is how it is.
\item It has dependency management so that you can have processes start only after others
    have finished.
\item It still uses simple files to configure itself that are in separate directories.
\item It can be run as root, and like Mongrel2 it will drop privileges to the owner 
    of the profile directory before it runs the command.  This is incredibly useful because
    it lets you setup scripts that run as other users without much configuration or fuss.
\item It is dinky tiny and well written so you can understand it, even though it's written
    in C.
\item Best of all, I can use it in this book and you won't go insane trying to install it
    or use it like the others.
\end{enumerate}

Of course, if you have something else you like then please use it.  Anything that automates
process management will be your friend.  In this manual, to keep things simple and easily
understood I'll be using \shell{procer} to tell you how to setup everything.

\subsection{Installing procer}

Installing procer is very easy.  It's a single little binary and it lives in 
\file{examples/procer} in the Mongrel2 source.  Here's how you'd install it
totally from scratch as if you hadn't even build Mongrel2 yet:

\begin{code}{Install procer}
\begin{Verbatim}
> cd projects/mongrel2
> make clean all install
> cd examples/procer
> make clean all install
\end{Verbatim}
\end{code}

That's the entire install process, and now procer is in \file{/usr/local/bin}
so you can use it.  In the rest of this chapter you'll learn how to use \shell{procer}
by just setting up the Mongrel2 demo completely and messing around with it.


\section{The Plan}

We need to plan this deployment to make sure we get the end result correct:

\begin{enumerate}
\item Create a deployment area where everything will live.
\item Create a config.sqlite that will work with the demos in \shell{examples}.
\item Setup procer to run mongrel2 and the three demo Python scripts for chat, handlertest, and mp3stream,
    and have it run the fake backend web.py project so we have something to proxy to.
\item Get all the static file content working.
\item Test out that procer is keeping things running and play with taking things down and up and using
    \shell{m2sh} to work with the deployment.
\end{enumerate}

Once you have this setup working you can then start to make your own
deployments and tweak things as you need for your own applications.  Remember
that the goal is to get you to \emph{automate} everything as much as possible,
so you can go further than this then do it.

\section{Step 1: The Deployment Area}

We'll need a place to put all this stuff and run it so that Mongrel2 can chroot
there, procer knows where its profiles are, and its all nice and clean.  For these
instructions we're just going to make some directories in your home directory,
but feel free to change this up later if you find a better way.

\begin{code}{Make Deployment Directories}
\begin{Verbatim}
# go home first
> cd ~/

# create the deployment dir
> mkdir deployment
> cd deployment/

# fill it with the directories we need
deployment > mkdir run
deployment > mkdir tmp
deployment > mkdir logs
deployment > mkdir profiles

# create the procer profile dirs for each thing
deployment > cd profiles/
deployment/profiles > mkdir chat mp3stream handlertest web mongrel2

deployment/profiles > cd ..

# setup the mongrel2 database initially
deployment > m2sh init -db config.sqlite

# copy the mongrel2_conf.py sample from the source to here
deployment > cp ~/projects/mongrel2/examples/python/tests/mongrel2_org.py config.py

# see our end results
deployment > ls
config.py  config.sqlite  logs	profiles  run  tmp

\end{Verbatim}
\end{code}

Hopefully you're starting to see how you could easily automate this so that you don't
have to do this all the time.  I'm just showing you how to "make the sausage" so that
you know where everything goes.  Future versions of \shell{m2sh} will most likely 
create deployment directories like this automatically.

What we've done here is the following:

\begin{enumerate}
\item Setup a ~/deployment directory we'll put everything inside.
\item Created run, tmp, logs, and profiles that Mongrel2 and procer need to run.
\item In profiles we started dirs for chat, mp3stream, handlertest, web, and mongrel2
    that procer will read files out of to get all our gear up and running.
\item Initialized the config.sqlite file we'll be filling in with our modififed config.py.
\item Copied the mongrel2\_org.py example file over to our deployment so we can modify it.
\end{enumerate}


\section{Step 2: The mongrel2.org Configuration}

Now we're ready to get the configuration working.  Here's the thing though, you should 
try to alter the configuration yourself.  I've already given you the file and you are
going to have to make the changes to meet the requirements for this deployment directory.
Here's what yo have to change in \file{config.py} to make everything work right:

\begin{enumerate}
\item Get rid of the \ident{test\_directory} handler since we won't need it and
    any routes that mention it.
\item Change the \ident{base} of \ident{chat\_demo\_dir} to \file{'static/chatdemo'} which we'll setup at the end.
\item Modify the server \ident{chroot} so that it's \file{/home/YOU/deployment/}.
\item Use the \shell{m2sh uuid} command to make some new UUIDs for all the 
    existing ones.  This is optional but probably good idea to get in the 
    habit now.
\item Finally, change any mention of "mongrel2.org" into "localhost" so that you
    can run it locally.
\end{enumerate}

Once you have that all edited, you should be able to run \shell{m2sh load -db
config.sqlite -config config.py} and it'll just load it up.  Try using
\shell{m2sh servers} and \shell{m2sh hosts} to take a peek.


To test it out at this stage you can just run the config.sqlite that you
did with these commands:

\begin{code}{Testing The Initial Configuration}
\begin{Verbatim}
> m2sh start -db config.sqlite -host localhost
^C
> m2sh start -db config.sqlite -host localhost -sudo
> less run/mongrel2.logs
> m2sh stop -db config.sqlite -host localhost -murder
\end{Verbatim}
\end{code}

That's enough to make sure it runs, but you've got nothing running
so it mostly won't work at all.  Just start up and then kill it
right after.


\section{Step 3: Setup procer}



\section{Step 4: Static Content}

\section{Step 5: Testing It}


\section{Further Improvements}



